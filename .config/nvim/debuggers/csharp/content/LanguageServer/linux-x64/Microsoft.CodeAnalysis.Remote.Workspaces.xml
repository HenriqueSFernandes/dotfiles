<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Remote.Workspaces</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.Remote.AbstractAssetProvider">
            <summary>
            Provides corresponding data of the given checksum
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.AbstractAssetProvider.GetAssetAsync``1(Microsoft.CodeAnalysis.Serialization.AssetPath,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            return data of type T whose checksum is the given checksum
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.AbstractAssetProviderExtensions.GetAssetsArrayAsync``1(Microsoft.CodeAnalysis.Remote.AbstractAssetProvider,Microsoft.CodeAnalysis.Serialization.AssetPath,Microsoft.CodeAnalysis.Serialization.ChecksumCollection,System.Threading.CancellationToken)">
            <summary>
            Returns an array of assets, corresponding to all the checksums found in the given <paramref name="checksums"/>.
            The assets will be returned in the order corresponding to their checksum in <paramref name="checksums"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.CancellationTokenSourceExtensions.CancelOnAbnormalCompletion(System.Threading.CancellationTokenSource,System.Threading.Tasks.Task)">
            <summary>
            Automatically cancels the <paramref name="cancellationTokenSource"/> if the input <paramref name="task"/>
            completes in a <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> state.
            </summary>
            <param name="cancellationTokenSource">The cancellation token source.</param>
            <param name="task">The task to monitor.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteAssetSynchronizationService.SynchronizePrimaryWorkspaceAsync(Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Synchronize data to OOP proactively so that the corresponding solution is often already available when features
            call into it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteAssetSynchronizationService.SynchronizeTextChangesAsync(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Checksum,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Synchronize the text changes made by a user to a particular document as they are editing it.  By sending over
            the text changes as they happen, we can attempt to 'prime' the remote asset cache with a final <see
            cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that is built based off of retrieving the remote source text with a checksum corresponding
            to baseTextChecksum and then applying the textChanges to it.  Then, when the next remote call comes in for the
            new solution snapshot, it can hopefully just pluck that text out of the cache without having to sync the
            <em>entire</em> contents of the file over.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteAssetSynchronizationService.SynchronizeActiveDocumentAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Synchronize over what the user's current active document is that they're editing.  This can then be used by the
            remote side to help determine which documents are best to strongly hold onto data for, and which should just
            hold on weakly.  Given how much work happens on the active document, this can help avoid the remote side from
            continually creating and then throwing away that data.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.ISolutionAssetProvider">
            <summary>
            Brokered service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.ISolutionAssetProvider.WriteAssetsAsync(System.IO.Pipelines.PipeWriter,Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Serialization.AssetPath,System.ReadOnlyMemory{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Streams serialized assets into the given stream.  Assets will be serialized in the exact same order
            corresponding to the checksum index in <paramref name="checksums"/>.
            </summary>
            <param name="pipeWriter">The writer to write the assets into.  Implementations of this method must call<see
            cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> on it (in the event of failure or success).  Failing to do so will lead to hangs on
            the code that reads from the corresponding <see cref="T:System.IO.Pipelines.PipeReader"/> side of this.</param>
            <param name="assetPath">Optional project and document ids to scope the search for checksums down to.  This can
            save substantially on performance by avoiding having to search the full solution tree to find matching items for
            a particular checksum.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.ProjectSystem.IWorkspaceProjectBatch">
            <summary>
            A batch returned from <see cref="M:Microsoft.CodeAnalysis.Remote.ProjectSystem.IWorkspaceProject.StartBatchAsync(System.Threading.CancellationToken)" />. <see cref="M:Microsoft.CodeAnalysis.Remote.ProjectSystem.IWorkspaceProjectBatch.ApplyAsync(System.Threading.CancellationToken)" /> must be called before disposing the batch object, which is otherwise a no-op.
            The dispose just releases any lifetime object tracking since this is an [RpcMarshalable] type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.ProjectSystem.IWorkspaceProjectFactoryService.GetSupportedBuildSystemPropertiesAsync(System.Threading.CancellationToken)">
            <summary>
            Returns the list of properties that are understood by the language service and can be passed to
            <see cref="M:Microsoft.CodeAnalysis.Remote.ProjectSystem.IWorkspaceProject.SetBuildSystemPropertiesAsync(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String},System.Threading.CancellationToken)"/> and to
            <see cref="P:Microsoft.CodeAnalysis.Remote.ProjectSystem.WorkspaceProjectCreationInfo.BuildSystemProperties"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteCallback`1">
            <summary>
            Wraps calls from a remote brokered service back to the client or to an in-proc brokered service.
            The purpose of this type is to handle exceptions thrown by the underlying remoting infrastructure
            in manner that's compatible with our exception handling policies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteCallback`1.InvokeServiceAsync(Microsoft.ServiceHub.Framework.ServiceBrokerClient,Microsoft.ServiceHub.Framework.ServiceRpcDescriptor,System.Func{Microsoft.CodeAnalysis.Remote.RemoteCallback{`0},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)">
            <summary>
            Use to perform a callback from ServiceHub process to an arbitrary brokered service hosted in the original process (usually devenv).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteCallback`1.InvokeAsync(System.Func{`0,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)">
            <summary>
            Invokes API on the callback object hosted in the original process (usually devenv) associated with the currently executing brokered service hosted in ServiceHub process.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteCallback`1.InvokeAsync``1(System.Func{`0,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)">
            <summary>
            Invokes API on the callback object hosted in the original process (usually devenv) associated with the currently executing brokered service hosted in ServiceHub process.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteCallback`1.InvokeAsync(System.Func{`0,System.IO.Pipelines.PipeWriter,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Func{System.IO.Pipelines.PipeReader,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)">
            <summary>
            Invokes API on the callback object hosted in the original process (usually devenv) associated with the
            currently executing brokered service hosted in ServiceHub process. The API streams results back to the
            caller.
            </summary>
            <param name="invocation">A callback to asynchronously write data. The callback should always <see
            cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> the <see cref="T:System.IO.Pipelines.PipeWriter"/>.  If it does not then reading will hang</param>
            <param name="reader">A callback to asynchronously read data. The callback should not complete the <see
            cref="T:System.IO.Pipelines.PipeReader"/>, but no harm will happen if it does.</param>
            <param name="cancellationToken">A cancellation token the operation will observe.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteHostAssetReader`2">
            <summary>
            See <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostAssetWriter"/> for an explanation of the wire format we use when communicating assets
            between the host and our OOP server.  This implements the code for reading assets transmitted over the wire.  <see
            cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostAssetWriter"/> has the code for writing assets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostAssetReader`2.#ctor(System.IO.Pipelines.PipeReader,Microsoft.CodeAnalysis.Checksum,System.Int32,Microsoft.CodeAnalysis.Serialization.ISerializerService,System.Action{Microsoft.CodeAnalysis.Checksum,`0,`1},`1)">
            <summary>
            See <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostAssetWriter"/> for an explanation of the wire format we use when communicating assets
            between the host and our OOP server.  This implements the code for reading assets transmitted over the wire.  <see
            cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostAssetWriter"/> has the code for writing assets.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteHostAssetWriter">
            <summary>
            Contains the utilities for writing assets from the host to a pipe-writer and for reading those assets on the
            server.  The format we use is as follows.  For each asset we're writing we write:
            <code>
            -------------------------------------------------------------------------
            | sentinel (1 byte) | length of data (4 bytes) | data (variable length) |
            -------------------------------------------------------------------------
            </code>
            The writing code will write out the sentinel-byte and data-length, ensuring it is flushed to the pipe-writer. This
            allows the pipe-reader to immediately read that information so it can then pre-allocate the space for the data to go
            into. After writing the data the writer will also flush, so the reader can then read the data out of the pipe into
            its buffer.  Once present in the reader's buffer, synchronous deserialization can happen without any sync-over-async
            blocking on async-io.
            <para/> The sentinel byte serves to let us detect immediately on the reading side if something has gone wrong with
            this system.
            <para/> In order to be able to write out the data-length, the writer will first synchronously write the asset to an
            in-memory buffer, then write that buffer's length to the pipe-writer, then copy the in-memory buffer to the writer.
            <para/> When writing/reading the data-segment, we use an the <see cref="T:Roslyn.Utilities.ObjectWriter"/>/<see cref="T:Roslyn.Utilities.ObjectReader"/>
            subsystem.  This will write its own validation bits, and then the data describing the asset.  This data is:
            <code>
            ----------------------------------------------------------------------------------------------------------
            | data (variable length)                                                                                 |
            ----------------------------------------------------------------------------------------------------------
            | ObjectWriter validation (2 bytes) | checksum (16 bytes) | kind (1 byte) | asset-data (asset specified) |
            ----------------------------------------------------------------------------------------------------------
            </code>
            The validation bytes are followed by the checksum.  The checksum is needed in the message as assets can be found in
            any order (they are not reported in the order of the array of checksums passed into the writing method). Following
            this is the kind of the asset.  This kind is used by the reading code to know which asset-deserialization routine to
            invoke. Finally, the asset data itself is written out.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostAssetWriter.#ctor(System.IO.Pipelines.PipeWriter,Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.Scope,Microsoft.CodeAnalysis.Serialization.AssetPath,System.ReadOnlyMemory{Microsoft.CodeAnalysis.Checksum},Microsoft.CodeAnalysis.Serialization.ISerializerService)">
            <summary>
            Contains the utilities for writing assets from the host to a pipe-writer and for reading those assets on the
            server.  The format we use is as follows.  For each asset we're writing we write:
            <code>
            -------------------------------------------------------------------------
            | sentinel (1 byte) | length of data (4 bytes) | data (variable length) |
            -------------------------------------------------------------------------
            </code>
            The writing code will write out the sentinel-byte and data-length, ensuring it is flushed to the pipe-writer. This
            allows the pipe-reader to immediately read that information so it can then pre-allocate the space for the data to go
            into. After writing the data the writer will also flush, so the reader can then read the data out of the pipe into
            its buffer.  Once present in the reader's buffer, synchronous deserialization can happen without any sync-over-async
            blocking on async-io.
            <para/> The sentinel byte serves to let us detect immediately on the reading side if something has gone wrong with
            this system.
            <para/> In order to be able to write out the data-length, the writer will first synchronously write the asset to an
            in-memory buffer, then write that buffer's length to the pipe-writer, then copy the in-memory buffer to the writer.
            <para/> When writing/reading the data-segment, we use an the <see cref="T:Roslyn.Utilities.ObjectWriter"/>/<see cref="T:Roslyn.Utilities.ObjectReader"/>
            subsystem.  This will write its own validation bits, and then the data describing the asset.  This data is:
            <code>
            ----------------------------------------------------------------------------------------------------------
            | data (variable length)                                                                                 |
            ----------------------------------------------------------------------------------------------------------
            | ObjectWriter validation (2 bytes) | checksum (16 bytes) | kind (1 byte) | asset-data (asset specified) |
            ----------------------------------------------------------------------------------------------------------
            </code>
            The validation bytes are followed by the checksum.  The checksum is needed in the message as assets can be found in
            any order (they are not reported in the order of the array of checksums passed into the writing method). Following
            this is the kind of the asset.  This kind is used by the reading code to know which asset-deserialization routine to
            invoke. Finally, the asset data itself is written out.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteHostAssetWriter.MessageSentinelByte">
            <summary>
            A sentinel byte we place between messages.  Ensures we can detect when something has gone wrong as soon as
            possible. Note: the value we pick is neither ascii nor extended ascii.  So it's very unlikely to appear
            accidentally.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteProcessConfiguration.ServerGC">
            <summary>
            Remote host uses server GC.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteSerializationOptions">
            <summary>
            Wraps MessagePack or JSON serialization options/converters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.MessagePackFormatters">
            <summary>
            Defines MessagePack formatters for public types without a public constructor suitable for deserialization.
            Roslyn internal types should always be annotated with <see cref="T:System.Runtime.Serialization.DataContractAttribute"/> and have the right constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.MessagePackFormatters.ProjectIdFormatter">
            <summary>
            Specialized formatter used so we can cache and reuse <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> instances.  This is valuable as
            it's very common for a set of results to reuse the same ProjectId across long sequences of results
            containing <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s.  This allows a single instance to be created and shared across that
            entire sequence, saving on allocations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.MessagePackFormatters.ProjectIdFormatter._projectIds">
            <summary>
            Cache of previously (de)serialized ProjectIDs. This cache allows a particular ProjectId
            to only serialize or deserialize it's DebugName once. Additionally, this cache allows
            the Deserialization code to only construct the ProjectID a single time.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.MessagePackFormatters.EncodingFormatter">
            <summary>
            Supports (de)serialization of <see cref="T:System.Text.Encoding"/> that do not customize <see cref="P:System.Text.Encoding.EncoderFallback"/> or <see cref="P:System.Text.Encoding.DecoderFallback"/>.
            The fallback will be discarded if the <see cref="T:System.Text.Encoding"/> has any.
            </summary>
            <remarks>
            Only supports (de)serializing values that are statically typed to <see cref="T:System.Text.Encoding"/>.
            This is important as we can't assume anything about arbitrary subtypes of <see cref="T:System.Text.Encoding"/>
            and can only return general <see cref="T:System.Text.Encoding"/> from the deserializer.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.ServiceDescriptor">
            <summary>
            Describes Roslyn remote brokered service. 
            Adds Roslyn specific JSON converters and RPC settings to the default implementation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.ServiceDescriptor.ServiceNameTopLevelPrefix">
            <summary>
            Brokered services must be defined in Microsoft.VisualStudio service namespace in order to be considered first party.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.ServiceDescriptors">
            <summary>
            Service descriptors of brokered Roslyn ServiceHub services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.ServiceDescriptors.GetFeatureDisplayName(System.String)">
            <summary>
            <paramref name="serviceName"/> is a short service name, e.g. "EditAndContinue".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.ServiceHubRemoteHostClient.CreateConnection``1(System.Object)">
            <summary>
            Creates connection to built-in remote service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.ServiceHubRemoteHostClient.CreateConnection``1(Microsoft.CodeAnalysis.Remote.ServiceDescriptors,Microsoft.CodeAnalysis.Remote.IRemoteServiceCallbackDispatcherProvider,System.Object)">
            <summary>
            This overload is meant to be used by partner teams from their External Access layer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.SolutionAssetProvider">
            <summary>
            Provides solution assets present locally (in the current process) to a remote process where the solution is being replicated to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetProvider.#ctor(Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            Provides solution assets present locally (in the current process) to a remote process where the solution is being replicated to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage">
            <summary>
            Stores solution snapshots available to remote services.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage._gate">
            <summary>
            Lock over <see cref="F:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage._checksumToScope"/>.  Note: We could consider making this a SemaphoreSlim if
            the locking proves to be a problem. However, it would greatly complicate the implementation and consumption
            side due to the pattern around <c>await using</c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage._checksumToScope">
            <summary>
            Mapping from operation checksum to the scope for the syncing operation that we've created for it.
            Ref-counted so that if we have many concurrent calls going out from the host to the OOP side that we share
            the same storage here so that all OOP calls can safely call back into us and get the assets they need, even
            if individual calls get canceled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.StoreAssetsAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Adds given snapshot into the storage. This snapshot will be available within the returned <see cref="T:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.Scope"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.StoreAssetsAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.StoreAssetsAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.StoreAssetsAsync(Microsoft.CodeAnalysis.SolutionCompilationState,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.StoreAssetsAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.StoreAssetsAsync(Microsoft.CodeAnalysis.SolutionCompilationState,Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.StoreAssetsAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.Scope.RefCount">
            <summary>
            Only safe to read write while <see cref="F:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage._gate"/> is held.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.Scope.FindAssetsAsync``1(Microsoft.CodeAnalysis.Serialization.AssetPath,System.ReadOnlyMemory{Microsoft.CodeAnalysis.Checksum},System.Action{Microsoft.CodeAnalysis.Checksum,System.Object,``0},``0,System.Threading.CancellationToken)">
            <summary>
            Retrieve assets of specified <paramref name="checksums"/> available within <see langword="this"/> from
            the storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetStorage.Scope.TestAccessor.GetAssetAsync(Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Retrieve asset of a specified <paramref name="checksum"/> available within <see langword="this"/> from
            the storage.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.Feature_0_is_currently_unavailable_host_shutting_down">
            <summary>Feature '{0}' is currently unavailable since {1} is shutting down.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.Feature_0_is_currently_unavailable_due_to_an_intermittent_error">
            <summary>Feature '{0}' is currently unavailable due to an intermittent error, please try again later: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.Feature_0_is_currently_unavailable_due_to_an_internal_error">
            <summary>Feature '{0}' is currently unavailable due to an internal error.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_MissingImportDiscovery">
            <summary>Missing import discovery</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_CodeLensReferences">
            <summary>CodeLens references</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_ConvertTupleToStructCodeRefactoring">
            <summary>Convert tuple to struct refactoring</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_DependentTypeFinder">
            <summary>Dependent type finder</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_DesignerAttributeDiscovery">
            <summary>DesignerAttribute discovery</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_DiagnosticAnalyzer">
            <summary>Diagnostic analyzer runner</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_DocumentHighlights">
            <summary>Document highlights</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_EncapsulateField">
            <summary>Encapsulate field refactoring</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_ExtensionMethodImportCompletion">
            <summary>Extension method import completion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_FindUsages">
            <summary>Find usages</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_FullyQualify">
            <summary>Fully qualify</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_GlobalNotificationDelivery">
            <summary>Global notification delivery</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_NavigateToSearch">
            <summary>Navigate to</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_ProjectTelemetry">
            <summary>Project telemetry collection</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_Renamer">
            <summary>Rename</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_SemanticClassification">
            <summary>Semantic classification</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_SymbolFinder">
            <summary>Symbol finder</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_SymbolSearchUpdate">
            <summary>Symbol search</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_TaskList">
            <summary>Task list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_AsynchronousOperationListener">
            <summary>Asynchronous operation listener</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_AssetSynchronization">
            <summary>Asset synchronization</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_SolutionAssetProvider">
            <summary>Asset provider</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_EditAndContinue">
            <summary>Edit and Continue</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_NavigationBarItem">
            <summary>Navigation bar</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_InheritanceMargin">
            <summary>Inheritance margin</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_UnusedReferenceAnalysis">
            <summary>Unused reference analysis</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_ValueTracking">
            <summary>Value Tracking</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_ProcessTelemetry">
            <summary>Process telemetry</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_CompilationAvailable">
            <summary>Project semantics availability</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_StackTraceExplorer">
            <summary>Stack Trace Explorer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_LegacySolutionEventsAggregation">
            <summary>Solution Events</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_UnitTestingSearch">
            <summary>Unit testing search</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_KeepAlive">
            <summary>Keep alive service</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_SourceGeneration">
            <summary>Source generation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_SemanticSearch">
            <summary>Semantic search</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspacesResources.FeatureName_RelatedDocuments">
            <summary>Related documents</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors">
            <summary>
            Descriptors of brokered services not used by Roslyn remoting infrastructure.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.ClientServiceDescriptor">
            <summary>
            Descriptors for client services written in TypeScript.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.LanguageServerComponentName">
            <summary>
            Services proffered by Language Server process.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.LanguageClientComponentName">
            <summary>
            Services proffered by language client in the Extension Host process.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.DebuggerComponentName">
            <summary>
            Services proffered by one of the Debugger processes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.CreateClientServiceDescriptor(System.String,System.Version)">
            <summary>
            Descriptor for services proffered by the client extension (implemented in TypeScript).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.CreateServerServiceDescriptor(System.String,System.Version)">
            <summary>
            Descriptor for services proffered by Roslyn server or Visual Studio in-proc (implemented in C#). 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.CreateDebuggerServiceDescriptor(System.String,System.Version,Nerdbank.Streams.MultiplexingStream.Options)">
            <summary>
            Descriptor for services proffered by the debugger server (implemented in C#). 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.CreateDebuggerClientServiceDescriptor(System.String,System.Version)">
            <summary>
            Descriptor for services proffered by the debugger server (implemented in TypeScript).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.CreateWebToolsServiceDescriptor(System.String,System.Version)">
            <summary>
            Descriptor for services proffered by the WebTools component (implemented in C# DevKit).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BrokeredServices.BrokeredServiceDescriptors.CreateMauiServiceDescriptor(System.String,System.Version)">
            <summary>
            Descriptor for services proffered by the MAUI extension (implemented in TypeScript).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BrokeredServices.IOnServiceBrokerInitialized">
            <summary>
            Allow services to export IOnServiceBrokerInitialized and getting called back when service broker is initialized
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.ManagedHotReloadLanguageService.HasChangesAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Returns true if any changes have been made to the source since the last changes had been applied.
            For performance reasons it only implements a heuristic and may return both false positives and false negatives.
            If the result is a false negative the debugger will not apply the changes unless the user explicitly triggers apply change command.
            The background diagnostic analysis will still report rude edits for these ignored changes. It may also happen that these rude edits 
            will disappear once the debuggee is resumed - if they are caused by presence of active statements around the change.
            If the result is a false positive the debugger attempts to apply the changes, which will result in a delay but will correctly end up
            with no actual deltas to be applied.
            
            If <paramref name="sourceFilePath"/> is specified checks for changes only in a document of the given path.
            This is not supported (returns false) for source-generated documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaServiceDescriptorsWrapper.GetDescriptorForServiceFactory(System.Type)">
            <summary>
            To be called from a service factory in OOP.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingServiceDescriptorsWrapper.GetDescriptorForServiceFactory(System.Type)">
            <summary>
            To be called from a service factory in OOP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.VisualStudioMefHostServices">
            <summary>
            Provides host services imported via VS MEF.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.VisualStudioMefHostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> associated with the specified workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.VisualStudioMefHostServices.GetExports``2">
            <summary>
            Gets all the MEF exports of the specified type with the specified metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.VisualStudioMefHostServices.GetExports``1">
            <summary>
            Gets all the MEF exports of the specified type.
            </summary>
        </member>
    </members>
</doc>
